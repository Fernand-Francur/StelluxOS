#ifndef XCHI_H
#define XCHI_H
#include <ktypes.h>

#define XHCI_DCBAA_SIZE             256
#define XHCI_DOORBELL_ARRAY_SIZE    256

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 358)

Run/Stop (R/S) – RW. Default = ‘0’. ‘1’ = Run. ‘0’ = Stop. When set to a ‘1’, the xHC proceeds with
execution of the schedule. The xHC continues execution as long as this bit is set to a ‘1’. When this bit
is cleared to ‘0’, the xHC completes any current or queued commands or TDs, and any USB transactions
associated with them, then halts.
Refer to section 5.4.1.1 for more information on how R/S shall be managed.
The xHC shall halt within 16 ms. after software clears the Run/Stop bit if the above conditions have
been met.
The HCHalted (HCH) bit in the USBSTS register indicates when the xHC has finished its pending
pipelined transactions and has entered the stopped state. Software shall not write a ‘1’ to this flag
unless the xHC is in the Halted state (that is, HCH in the USBSTS register is ‘1’). Doing so may yield
undefined results. Writing a ‘0’ to this flag when the xHC is in the Running state (that is, HCH = ‘0’) and
any Event Rings are in the Event Ring Full state (refer to section 4.9.4) may result in lost events.
When this register is exposed by a Virtual Function (VF), this bit only controls the run state of the xHC
instance presented by the selected VF. Refer to section 8 for more information.
*/
#define XHCI_USBCMD_RUN_STOP                    (1 << 0)

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 358)

Host Controller Reset (HCRST) – RW. Default = ‘0’. This control bit is used by software to reset the
host controller. The effects of this bit on the xHC and the Root Hub registers are similar to a Chip
Hardware Reset.
When software writes a ‘1’ to this bit, the Host Controller resets its internal pipelines, timers, counters,
state machines, etc. to their initial value. Any transaction currently in progress on the USB is
immediately terminated. A USB reset shall not be driven on USB2 downstream ports, however a Hot or
Warm Reset79 shall be initiated on USB3 Root Hub downstream ports.
PCI Configuration registers are not affected by this reset. All operational registers, including port
registers and port state machines are set to their initial values. Software shall reinitialize the host
controller as described in Section 4.2 in order to return the host controller to an operational state.
This bit is cleared to ‘0’ by the Host Controller when the reset process is complete. Software cannot
terminate the reset process early by writing a ‘0’ to this bit and shall not write any xHC Operational or
Runtime registers until while HCRST is ‘1’. Note, the completion of the xHC reset process is not gated by
the Root Hub port reset process.
Software shall not set this bit to ‘1’ when the HCHalted (HCH) bit in the USBSTS register is a ‘0’.
Attempting to reset an actively running host controller may result in undefined behavior.
When this register is exposed by a Virtual Function (VF), this bit only resets the xHC instance presented
by the selected VF. Refer to section 8 for more information.
*/
#define XHCI_USBCMD_HCRESET                     (1 << 1)

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 359)

Interrupter Enable (INTE) – RW. Default = ‘0’. This bit provides system software with a means of
enabling or disabling the host system interrupts generated by Interrupters. When this bit is a ‘1’, then
Interrupter host system interrupt generation is allowed, for example, the xHC shall issue an interrupt at
the next interrupt threshold if the host system interrupt mechanism (for example, MSI, MSI-X, etc.) is
enabled. The interrupt is acknowledged by a host system interrupt specific mechanism.
When this register is exposed by a Virtual Function (VF), this bit only enables the set of Interrupters
assigned to the selected VF. Refer to section 7.7.2 for more information.
*/
#define XHCI_USBCMD_INTERRUPTER_ENABLE          (1 << 2)

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 359)

Host System Error Enable (HSEE) – RW. Default = ‘0’. When this bit is a ‘1’, and the HSE bit in the
USBSTS register is a ‘1’, the xHC shall assert out-of-band error signaling to the host. The signaling is
acknowledged by software clearing the HSE bit. Refer to section 4.10.2.6 for more information.
When this register is exposed by a Virtual Function (VF), the effect of the assertion of this bit on the
Physical Function (PF0) is determined by the VMM. Refer to section 8 for more information.
*/
#define XHCI_USBCMD_HOSTSYS_ERROR_ENABLE        (1 << 3)

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 359)

Light Host Controller Reset (LHCRST) – RO or RW. Optional normative. Default = ‘0’. If the Light
HC Reset Capability (LHRC) bit in the HCCPARAMS1 register is ‘1’, then this flag allows the driver to
reset the xHC without affecting the state of the ports.
A system software read of this bit as ‘0’ indicates the Light Host Controller Reset has completed and it is
safe for software to re-initialize the xHC. A software read of this bit as a ‘1’ indicates the Light Host
Controller Reset has not yet completed.
If not implemented, a read of this flag shall always return a ‘0’.
All registers in the Aux Power well shall maintain the values that had been asserted prior to the Light
Host Controller Reset. Refer to section 4.23.1 for more information.
When this register is exposed by a Virtual Function (VF), this bit only generates a Light Reset to the
xHC instance presented by the selected VF, for example, Disable the VFs’ device slots and set the
associated VF Run bit to Stopped. Refer to section 8 for more information.
*/
#define XHCI_USBCMD_LIGHT_HCRESET               (1 << 7)

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 359)

Controller Save State (CSS) - RW. Default = ‘0’. When written by software with ‘1’ and HCHalted
(HCH) = ‘1’, then the xHC shall save any internal state (that may be restored by a subsequent Restore
State operation) and if FSC = '1' any cached Slot, Endpoint, Stream, or other Context information (so
that software may save it). When written by software with ‘1’ and HCHalted (HCH) = ‘0’, or written with
‘0’, no Save State operation shall be performed. This flag always returns ‘0’ when read. Refer to the
Save State Status (SSS) flag in the USBSTS register for information on Save State completion. Refer to
section 4.23.2 for more information on xHC Save/Restore operation. Note that undefined behavior may
occur if a Save State operation is initiated while Restore State Status (RSS) = ‘1’.
When this register is exposed by a Virtual Function (VF), this bit only controls saving the state of the
xHC instance presented by the selected VF. Refer to section 8 for more information.
*/
#define XHCI_USBCMD_CSS                         (1 << 8)

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 359)

Controller Restore State (CRS) - RW. Default = ‘0’. When set to ‘1’, and HCHalted (HCH) = ‘1’, then
the xHC shall perform a Restore State operation and restore its internal state. When set to ‘1’ and
Run/Stop (R/S) = ‘1’ or HCHalted (HCH) = ‘0’, or when cleared to ‘0’, no Restore State operation shall
be performed. This flag always returns ‘0’ when read. Refer to the Restore State Status (RSS) flag in
the USBSTS register for information on Restore State completion. Refer to section 4.23.2 for more
information. Note that undefined behavior may occur if a Restore State operation is initiated while Save
State Status (SSS) = ‘1’.
When this register is exposed by a Virtual Function (VF), this bit only controls restoring the state of the
xHC instance presented by the selected VF. Refer to section 8 for more information.
*/
#define XHCI_USBCMD_CRS                         (1 << 9)

/*
// xHci Spec Section 5.4.1 USB Table 5-20: USB Command Register Bit Definitions (USBCMD) (page 359)

Enable Wrap Event (EWE) - RW. Default = ‘0’. When set to ‘1’, the xHC shall generate a MFINDEX
Wrap Event every time the MFINDEX register transitions from 03FFFh to 0. When cleared to ‘0’ no
MFINDEX Wrap Events are generated. Refer to section 4.14.2 for more information.
When this register is exposed by a Virtual Function (VF), the generation of MFINDEX Wrap Events to VFs
shall be emulated by the VMM. 
*/
#define XHCI_USBCMD_EWE                         (1 << 10)

/*
// xHci Spec Section 5.3 Table 5-9: eXtensible Host Controller Capability Registers (page 346)

These registers specify the limits and capabilities of the host controller
implementation.
All Capability Registers are Read-Only (RO). The offsets for these registers are
all relative to the beginning of the host controller’s MMIO address space. The
beginning of the host controller’s MMIO address space is referred to as “Base”.
*/
struct XhciCapabilityRegisters {
    uint8_t caplength;    // Capability Register Length
    uint8_t reserved0;
    uint16_t hciversion;  // Interface Version Number
    uint32_t hcsparams1;  // Structural Parameters 1
    uint32_t hcsparams2;  // Structural Parameters 2
    uint32_t hcsparams3;  // Structural Parameters 3
    uint32_t hccparams1;  // Capability Parameters 1
    uint32_t dboff;       // Doorbell Offset
    uint32_t rtsoff;      // Runtime Register Space Offset
    uint32_t hccparams2;  // Capability Parameters 2
};

/*
// xHci Spec Section 5.4 Table 5-18: Host Controller Operational Registers (page 356)

The base address of this register space is referred to as Operational Base.
The Operational Base shall be Dword aligned and is calculated by adding the
value of the Capability Registers Length (CAPLENGTH) register (refer to Section
5.3.1) to the Capability Base address. All registers are multiples of 32 bits in
length.
Unless otherwise stated, all registers should be accessed as a 32-bit width on
reads with an appropriate software mask, if needed. A software
read/modify/write mechanism should be invoked for partial writes.
These registers are located at a positive offset from the Capabilities Registers
(refer to Section 5.3).
*/
struct XhciOperationalRegisters {
    uint32_t usbcmd;      // USB Command
    uint32_t usbsts;      // USB Status
    uint32_t pagesize;    // Page Size
    uint32_t reserved0[2];
    uint32_t dnctrl;      // Device Notification Control
    uint64_t crcr;        // Command Ring Control
    uint32_t reserved1[4];
    uint64_t dcbaap;      // Device Context Base Address Array Pointer
    uint32_t config;      // Configure
    uint32_t reserved2[49];
    // Port Register Set offset has to be calculated dynamically based on MAXPORTS
};

/*
// xHci Spec Section 4.11 Figure 4-13: TRB Template (page 188)

This section discusses the properties and uses of TRBs that are outside of the
scope of the general data structure descriptions that are provided in section
6.4.
*/
struct XhciTransferRequestBlock {
    uint64_t parameter; // TRB-specific parameter
    uint32_t status;    // Status information
    uint32_t control;   // Control bits, including the TRB type
};

/*
// xHci Spec Section 5.5.2 (page 389)

Note: All registers of the Primary Interrupter shall be initialized before
setting the Run/Stop (RS) flag in the USBCMD register to ‘1’. Secondary
Interrupters may be initialized after RS = ‘1’, however all Secondary
Interrupter registers shall be initialized before an event that targets them is
generated. Not following these rules, shall result in undefined xHC behavior.
*/
struct XhciInterrupterRegisters {
    uint32_t iman;         // Interrupter Management (offset 00h)
    uint32_t imod;         // Interrupter Moderation (offset 04h)
    uint32_t erstsz;       // Event Ring Segment Table Size (offset 08h)
    uint32_t rsvdP;        // Reserved (offset 0Ch)
    uint64_t erstba;       // Event Ring Segment Table Base Address (offset 10h)
    uint64_t erdp;         // Event Ring Dequeue Pointer (offset 18h)
};

/*
// xHci Spec Section 5.5 Table 5-35: Host Controller Runtime Registers (page 388)

This section defines the xHCI Runtime Register space. The base address of this
register space is referred to as Runtime Base. The Runtime Base shall be 32-
byte aligned and is calculated by adding the value Runtime Register Space
Offset register (refer to Section 5.3.8) to the Capability Base address. All
Runtime registers are multiples of 32 bits in length.
Unless otherwise stated, all registers should be accessed with Dword references
on reads, with an appropriate software mask if needed. A software
read/modify/write mechanism should be invoked for partial writes.
Software should write registers containing a Qword address field using only
Qword references. If a system is incapable of issuing Qword references, then 
388 Document Number: 625472, Revision: 1.2b Intel Confidential
writes to the Qword address fields shall be performed using 2 Dword
references; low Dword-first, high-Dword second.
*/
struct XhciRuntimeRegisters {
    uint32_t mfIndex;                          // Microframe Index (offset 0000h)
    uint32_t rsvdZ[7];                         // Reserved (offset 001Fh:0004h)
    XhciInterrupterRegisters ir[1024];         // Interrupter Register Sets (offset 0020h to 8000h)
};

/*
// xHci Spec Section 4.2 Host Controller Initialization (page 68)

When the system boots, the host controller is enumerated, assigned a base
address for the xHC register space, and the system software sets the Frame
Length Adjustment (FLADJ) register to a system-specific value.
Refer to Section 4.23.1 Power Wells for a discussion of the effect of Power
Wells on register state after power-on and light resets.
Document Number: 625472, Revision: 1.2b 69
Following are a review of the operations that system software would perform in
order to initialize the xHC using MSI-X as the interrupt mechanism5
:
• Initialize the system I/O memory maps, if supported.
• After Chip Hardware Reset6 wait until the Controller Not Ready (CNR) flag
in the USBSTS is ‘0’ before writing any xHC Operational or Runtime
registers.
Note: This text does not imply a specific order for the following operations, however
these operations shall be completed before setting the USBCMD register
Run/Stop (R/S) bit to ‘1’.
• Program the Max Device Slots Enabled (MaxSlotsEn) field in the CONFIG
register (5.4.7) to enable the device slots that system software is going to
use.
• Program the Device Context Base Address Array Pointer (DCBAAP) register
(Section 5.4.6 Device Context Base Address Array Pointer Register
(DCBAAP)) with a 64-bit address pointing to where the Device Context
Base Address Array is located.
• Define the Command Ring Dequeue Pointer by programming the Command
Ring Control Register (Section 5.4.5 Command Ring Control Register
(CRCR)) with a 64-bit address pointing to the starting address of the first
TRB of the Command Ring.
• Initialize interrupts7 by:
o Allocate and initialize the MSI-X Message Table (Section 5.2.8.3 MSI-X
Table), setting the Message Address and Message Data, and enable the
vectors. At a minimum, table vector entry 0 shall be initialized and
enabled. Refer to the PCI specification for more details.
o Allocate and initialize the MSI-X Pending Bit Array (PBA, Section 5.2.8.4
MSI-X PBA).
o Point the Table Offset and PBA Offsets in the MSI-X Capability Structure
to the MSI-X Message Control Table and Pending Bit Array,
respectively.
o Initialize the Message Control register (Section 5.2.8.3 MSI-X Table) of
the MSI-X Capability Structure.
o Initialize each active interrupter by:
▪ Defining the Event Ring: (refer to Section 4.9.4 Event Ring
Management for a discussion of Event Ring Management.)
• Allocate and initialize the Event Ring Segment(s).
5Refer to the PCI spec for the initialization and use of MSI or PIN interrupt mechanisms
6A Chip Hardware Reset may be either a PCI reset input or an optional power-on reset input to the xHC.
7
Interrupts are optional. The xHC may be managed by polling Event Rings.
70 Document Number: 625472, Revision: 1.2b
Intel Confidential
• Allocate the Event Ring Segment Table (ERST) (Section 6.5
Event Ring Segment Table). Initialize ERST table entries to
point to and to define the size (in TRBs) of the respective Event
Ring Segment.
• Program the Interrupter Event Ring Segment Table Size
(ERSTSZ) register (Section 5.5.2.3.1 Event Ring Segment Table
Size Register (ERSTSZ)) with the number of segments
described by the Event Ring Segment Table.
• Program the Interrupter Event Ring Dequeue Pointer (ERDP)
register (Section 5.5.2.3.3 Event Ring Dequeue Pointer Register
(ERDP)) with the starting address of the first segment
described by the Event Ring Segment Table.
• Program the Interrupter Event Ring Segment Table Base
Address (ERSTBA) register (Section 5.5.2.3.2 Event Ring
Segment Table Base Address Register (ERSTBA)) with a 64-bit
address pointer to where the Event Ring Segment Table is
located.
• Note that writing the ERSTBA enables the Event Ring. Refer to
Section 4.9.4 Event Ring Management for more information on
the Event Ring registers and their initialization.
▪ Defining the interrupts:
• Enable the MSI-X interrupt mechanism by setting the MSI-X
Enable flag in the MSI-X Capability Structure Message Control
register (5.2.8.3).
• Initializing the Interval field of the Interrupt Moderation register
(5.5.2.2) with the target interrupt moderation rate.
• Enable system bus interrupt generation by writing a ‘1’ to the
Interrupter Enable (INTE) flag of the USBCMD register (5.4.1).
• Enable the Interrupter by writing a ‘1’ to the Interrupt Enable
(IE) field of the Interrupter Management register (5.5.2.1).
• Write the USBCMD (5.4.1) to turn the host controller ON via setting the
Run/Stop (R/S) bit to ‘1’. This operation allows the xHC to begin accepting
doorbell references.
*/
void xhciControllerInit(size_t bar);

#endif
